
rules_version = '2';

// Firestore Rules
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readability and reuse.

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * Use this for rules based on document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner of an EXISTING document.
     * CRITICAL: Use for all update and delete operations to prevent writes to non-existent paths.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Fetches the role from the requesting user's own user document.
     * Caches the result of the get() call for the request evaluation.
     */
    function getUserData() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    /**
     * Returns true if the user has the 'Super Admin' role.
     */
    function isSuperAdmin() {
      return isSignedIn() && getUserData().role == 'Super Admin';
    }

    /**
     * Returns true if the user has the 'Marketing Manager' role.
     */
    function isMarketingManager() {
      return isSignedIn() && getUserData().role == 'Marketing Manager';
    }

    /**
     * Returns true if the user has the 'Finance' role.
     */
    function isFinance() {
      return isSignedIn() && getUserData().role == 'Finance';
    }

    /**
     * @description
     *   Manages user profiles. Users can create their own profile and manage their
     *   own information. Only a Super Admin can modify user roles or delete accounts.
     * @path
     *   `/users/{userId}`
     * @allow
     *   A newly signed-up user (auth.uid: 'user123') can (create) their own profile at `/users/user123`.
     *   An existing user (auth.uid: 'user123') can (update) their own profile at `/users/user123`.
     * @deny
     *   A user (auth.uid: 'user123') cannot (list) all documents in the `/users` collection.
     *   A standard user cannot (update) the `role` field in their own document.
     * @principle
     *   Enforces Self-Creation and Ownership, with role-based restrictions on sensitive fields.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if false;
      allow create: if (isOwner(userId) || isSuperAdmin()) && request.resource.data.id == userId;
      allow update: if (isOwner(userId) && request.resource.data.id == resource.data.id && request.resource.data.role == resource.data.role && resource != null) || (isSuperAdmin() && resource != null);
      allow delete: if isSuperAdmin() && resource != null;
    }

    /**
     * @description
     *   Manages leads assigned to a specific user. Access is restricted to the
     *   user the lead is assigned to, ensuring data privacy between admission executives.
     * @path
     *   `/users/{userId}/leads/{leadId}`
     * @allow
     *   An admission executive (auth.uid: 'exec123') can (create) a lead at `/users/exec123/leads/leadABC`.
     * @deny
     *   An admission executive (auth.uid: 'exec123') cannot (get) a lead from `/users/exec456/leads/leadXYZ`.
     * @principle
     *   Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/leads/{leadId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if isOwner(userId) || isSuperAdmin();
      allow create: if (isOwner(userId) || isSuperAdmin()) && request.resource.data.assignedToId == userId;
      allow update: if (isExistingOwner(userId) || isSuperAdmin()) && request.resource.data.assignedToId == resource.data.assignedToId;
      allow delete: if isExistingOwner(userId) || isSuperAdmin();
    }

    /**
     * @description
     *   Manages marketing campaigns. Access is restricted to users with the
     *   'Marketing Manager' role for creating and managing campaign data.
     * @path
     *   `/campaigns/{campaignId}`
     * @allow
     *   A user with the 'Marketing Manager' role can (create), (update), and (list) all campaigns.
     * @deny
     *   A user with an 'Admission Executive' role cannot (get) or (list) campaigns.
     * @principle
     *   Enforces Role-Based Access Control (RBAC) for shared marketing data.
     */
    match /campaigns/{campaignId} {
      allow get: if isMarketingManager() || isSuperAdmin();
      allow list: if isMarketingManager() || isSuperAdmin();
      allow create: if isMarketingManager() || isSuperAdmin();
      allow update: if (isMarketingManager() || isSuperAdmin()) && resource != null;
      allow delete: if (isMarketingManager() || isSuperAdmin()) && resource != null;
    }

    /**
     * @description
     *   Manages budget requests within a campaign. Accessible by Marketing and Finance roles.
     * @path
     *   `/campaigns/{campaignId}/budgetRequests/{budgetId}`
     * @allow
     *   A 'Marketing Manager' can (create) a budget request. A 'Finance' user can (update) its status.
     * @deny
     *   An 'Admission Executive' cannot (get) or (list) any budget requests.
     * @principle
     *   Enforces multi-role RBAC for a workflow involving different departments.
     */
    match /campaigns/{campaignId}/budgetRequests/{budgetId} {
      allow get: if isMarketingManager() || isFinance() || isSuperAdmin();
      allow list: if isMarketingManager() || isFinance() || isSuperAdmin();
      allow create: if (isMarketingManager() || isSuperAdmin()) && request.resource.data.campaignId == campaignId;
      allow update: if ((isMarketingManager() || isFinance() || isSuperAdmin()) && resource != null) && request.resource.data.campaignId == resource.data.campaignId;
      allow delete: if (isMarketingManager() || isSuperAdmin()) && resource != null;
    }

    /**
     * @description
     *   Stores proof of payment documents. Reads are allowed for relevant roles, but
     *   writes are currently blocked due to a missing ownership field in the data model.
     * @path
     *   `/proofsOfPayment/{proofId}`
     * @allow
     *   A 'Finance' or 'Marketing Manager' user can (get) a proof of payment document.
     * @deny
     *   Any user attempting to (create) or (update) a proof of payment will be denied.
     * @principle
     *   Enforces a secure default by blocking writes that cannot be safely authorized.
     */
    match /proofsOfPayment/{proofId} {
      // CRITICAL: Cannot implement secure owner-only writes. The 'ProofOfPayment' entity is missing
      // an 'ownerId', 'creatorId', or 'marketingManagerId' field to validate against the requestor.
      allow get: if isMarketingManager() || isFinance() || isSuperAdmin();
      allow list: if isMarketingManager() || isFinance() || isSuperAdmin();
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description
     *   Stores call records, scoped to the user who made the call.
     * @path
     *   `/users/{userId}/callRecords/{callRecordId}`
     * @allow
     *   A user (auth.uid: 'user123') can (create) and (list) their own call records in `/users/user123/callRecords`.
     * @deny
     *   A user (auth.uid: 'user123') cannot (get) a call record from `/users/user456/callRecords/recordXYZ`.
     * @principle
     *   Restricts access to a user's own data tree using path-based security.
     */
    match /users/{userId}/callRecords/{callRecordId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if isOwner(userId) || isSuperAdmin();
      allow create: if (isOwner(userId) || isSuperAdmin()) && request.resource.data.agentId == userId;
      allow update: if (isExistingOwner(userId) || isSuperAdmin()) && request.resource.data.agentId == resource.data.agentId;
      allow delete: if isExistingOwner(userId) || isSuperAdmin();
    }

    /**
     * @description
     *   Stores advertising spend data, nested under the relevant campaign.
     *   Access is restricted to 'Marketing Manager' roles.
     * @path
     *   `/campaigns/{campaignId}/adSpend/{adSpendId}`
     * @allow
     *   A 'Marketing Manager' can (create) and (list) ad spend records for any campaign.
     * @deny
     *   A 'Finance' user cannot (create) an ad spend record.
     * @principle
     *   Enforces Role-Based Access Control (RBAC) for a subcollection.
     */
    match /campaigns/{campaignId}/adSpend/{adSpendId} {
      allow get: if isMarketingManager() || isSuperAdmin();
      allow list: if isMarketingManager() || isSuperAdmin();
      allow create: if (isMarketingManager() || isSuperAdmin()) && request.resource.data.campaignId == campaignId;
      allow update: if ((isMarketingManager() || isSuperAdmin()) && resource != null) && request.resource.data.campaignId == resource.data.campaignId;
      allow delete: if (isMarketingManager() || isSuperAdmin()) && resource != null;
    }
    
    /**
     * @description
     *   CRITICAL: This collection is fully locked down. The data structure makes it
     *   impossible to write a secure rule. To secure payments, they must be stored in a
     *   subcollection of the lead they belong to (e.g., /users/{userId}/leads/{leadId}/payments/{paymentId}).
     * @path
     *   `/leads/{leadId}/payments/{paymentId}`
     * @allow
     *   No operations are permitted.
     * @deny
     *   All users will be denied any read or write access.
     * @principle
     *   Enforces a secure default (deny all) when the data model prevents authorization checks.
     */
    match /leads/{leadId}/payments/{paymentId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}

// Realtime Database Rules
// This is not standard, but required to force deployment.
{
  "rules": {
    "smartflo_calls": {
      // Allow anyone to read from any sub-path of smartflo_calls
      ".read": true,
      // Keep writes restricted (only backend should write)
      ".write": false
    }
  }
}

    